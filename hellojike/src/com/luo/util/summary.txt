
版本
lucene          6.0.0
elasticsearch
luke            6.0.0   es gui 工具
    https://github.com/DmitryKey/luke/releases/download/luke-6.0.0/luke-6.0.0-luke-release.zip
IK分词器
    http://code.google.com/archive/p/ik-analyzer/downloads
    https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/ik-analyzer/IK%20Analyzer%202012_u6_source.rar
Tika    1.13    用于文件类型检测以及文件内容提取
    https://tika.apache.org/download.html
    java -jar tika-app-1.13.jar -g


StopAnalyzer    停用词分词器
    通过停用词进行分词
StandardAnalyzer 标准分词器
    通过空格和符号进行分割

TextField   会索引，会词条化，不会保存词向量。
    词向量是指TermVectors,记录每篇文档每个字段每个词的词频，位置，字符偏移量，playload信息
StringField 会索引，不会词条化，不会保存词向量。
DocValuesField  当lucene需要聚合或者排序时，会遍历所有字段并进行内部操作。
    DocValuesField会在索引的基础上，建立一个y已经排序好的Document->Field/Value 的映射列表
    减轻排序、分组时对内存的依赖。当然也会占用一部分空间。
IntPoint    索引int类型的值，只是做快速过滤。如果需要显示出来需要另外一个字段储存 ???有点奇怪
            这是因为IntPoint类型的字段，会将元素添加到PostingList中，如果需要储存需要单独添加一个StoreField类型字段



5 创建索引
put blogs
--创建索引默认5个分片,1个副本。分片数量指定后不能修改，而副本可以
put blogs
{
    "settings":{
        "number_of_shards":3,
        "number_of_replicas":1
    }
}
--更改副本数量,以及读写权限
put blogs/_settings
{
    "number_of_replicas":2,
    "blocks.read_only":true,    //设置当前索引只允许读,不允许更新
    "blocks.read":true,         //设置当前索引不可读
    "blocks.write":true         //设置当前索引不可写
}
--查看索引
get blogs/_settings
get blogs,blog/_settings
get _all/_settings
--删除索引
delete blog
--打开,关闭索引.关闭的索引几乎不占用资源
post blogs/_close
post blogs/_open
post blog,blogs/_close
post _all/_close
----操作不存在的索引会报错 测试发现没有生效?
post blogg/_close?ignore_unavailable=true
--复制索引
post _reindex
{
    "source":{"index":"blog"},
    "dest":{"index":"blog_new"}
}
----复制索引时,使用type和query来限制文档
post _reindex
{
    "sourcce":{
        "index":"blog",
        "type":"article",
        "query":{
            "term":{"title":"git"}
        }
    },
    "desc":{
        "index":"blog_new"
    }
}
----收缩索引.能将索引分片缩小
----将索引分片收缩到一个节点上,同时保持该索引只读
put blogsss/_settings
{
    "index.routing.allocation.require._name":"shrink_node_name",
    "index.blocks.write":true
}
----配置新索引的配置
post blogsss/_shrink/blogsss_new
{
    "settings":{
        "number_of_shards":3,
        "number_of_replicas":1,
        "index.codec":"best_compression"
    },
    "aliases":{
        "my_search_indices":{}
    }
}
--索引别名
----添加别名 actions 可以输入多个
post /_aliases
{
    "actions":[
        "add":{
            "index":"test1",
            "alias":"alias1"
        }
    ]
}
----移除别名
post /_aliases
{
    "actions":[
        "remove":{
            "index":"test1",
            "alias":"alias1"
        }
    ]
}
--查看别名
get /test/_aliases
--新建文档 指定id
put /blog/article/1
{
    "id":1,
    "title":"git简介",
    "posttime":"2017-01-02",
    "content":"Git是一款开源,免费的分布式版本控制软件"
}
--新建文档 不指定id
post /blog/article
{
    "id":1,
    "title":"git简介",
    "posttime":"2017-01-02",
    "content":"Git是一款开源,免费的分布式版本控制软件"
}
--获取文档 found表示是否找到,_source表示文档内容
get /blog/article/1
--判断是否存在 返回200-ok或者404
head /blog/article/1
--获取多个文档 mget api
get _mget
{
    "docs":[
        {
            "_index":"blog",
            "_type":"article",
            "_id":"1"
        },
        {
            "_index":"blogsss",
            "_id":"11"
        }
    ]
}
--更新文档
----先创建一条文档
put test/type1/1
{
    "counter":1,
    "tags":["red"]
}
----update api修改
----ctx是脚本语言的一个执行对象 .painless是es内置的脚本语言
----ctx还可以获取 _index,_type,_id,_version,_routing,_parent等
----给counter加四
post /test/type1/1/_update
{
    "script":{
        "inline":"ctx._source.counter+=params.count",
        "lang":"painless",
        "params":{
            "count":4
        }
    }
}
----给tags数组添加元素
post /test/type1/1/_update
{
    "script":{
        "inline":"ctx._source.tags.add(params.tag)",
        "lang":"painless",
        "params":{
            "tag":"blue"
        }
    }
}
----给文档添加一个属性
post /test/type1/1/_update
{
    "script":{
        "inline":"ctx._source.name=\"luoluoluo\""
    }
}
----给文档删除一个属性
post /test/type1/1/_update
{
    "script":{
        "inline":"ctx._source.remove(\"name\")"
    }
}
----删除tags数组中含有red的文档
----ctx.op 表示操作类型,delete表示删除,none表示不操作
post /test/type1/1/_update
{
	"script": {
		"inline": "if(ctx._source.tags.contains(params.tag)) {ctx.op = \"delete\"}else {ctx.op = \"none\"}",
		"lang": "painless",
		"params": {
			"tag": "red"
		}
	}
}
----更新还有一个 upsert,表示当存在则更新,不存在则新建一个文档
post /test/type1/1/_update
{
    "script":{
        "inline":"ctx._source.counter+=params.counter",
        "lang":"painless",
        "params":{
            "counter":4
        }
    },
    "upsert":{
        "counter":2
    }
}
----查询更新 使用update_by_query api
post /blog/article/_update_by_query
{
    "script":{
        "inline":"ctx._source.category+=params.category",
        "lang":"painless",
        "params":{
            "category":"git"
        }
    },
    "query":{
        "term":{
            "title":"git"
        }
    }
}
----删除文档
delete /blog/article/1
----如果索引文档添加了路由,删除时也可以添加路由
----指定了路由,那么储存的分片将会根据路由确定.对于该文档的查询,没有指定路由将无法查询到
delete /blog/article/1?routing=user123
----查询删除 使用 _delete_by_query
post /blog/article/_delete_by_query
{
    "query":{
        "term":{
            "title":"java"
        }
    }
}
----如果需要删除一个索引下的所有文档
post /blog/article/_delete_by_query
{
    "query":{
        "match_all":{}
    }
}
----批量操作 json文件每一行内容都需要换行
----注意一次提交的数据量.整个批量操作的内容会被加载到请求节点的内存中
----一般在5m到15m之间
curl -XPOST 'localhost:9200/website/_bulk?pretty' --data-binary @data.json
{"delete":{"_index":"website","_type":"blog","_id":123}}
{"create":{"_index":"website","_type":"blog","_id":123}}
{"title":"my first blog here"}
{"index":{"_index":"website","_type":"blog"}}
{"title":"my second blog here"}
{"update":{"_index":"website","_type":"blog","_id":123}}
{"doc":{"title":"my update blog post"}}
----版本控制
----获取某个版本的文档
get /website/blog/1?version=1
----指定当文档版本为多少时,才会进行更新
put /website/blog/123?version=2
{"title":"xxxx"}
----指定为外部版本,只有当外部指定的版本比原来版本高才会进行更新
put /website/blog/123?version=10&version_type=external
----路由机制,默认使用id作为路由值
shard=hash(routing) % number_of_primary_shard


--动态映射
json类型      es类型
null         不会被添加
true/false   boolean
浮点          float
数字          long
json对象      object类型
数组          由数组第一个元素决定
字符串         可能有date类型(开启日期检测),double,long,text类型,keyword类型
----测试动态映射
put /books
get /books/_mapping
----此时id被映射成long,publish_date被映射成date,name被映射成text,keyword
put /books/it/1
{
    "id":1,
    "publish_date":"2017-06-01",
    "name":"master ElasticSearch"
}
----在mapping中可以通过 dynamic 配置动态属性.默认为true,表示自动添加字段.false忽略新字段,strict严格模式,发现新字段抛出错误
put /books/
{
    "mappings":{
        "it":{
            "dynamic":"strict",
            "properties":{
                "title":{
                    "type":"text"
                },
                "publish_date":{
                    "type":"date"
                }
            }
        }
    }
}
----日期检测关闭 当新的字段第一次出现的值为时间字符串时,该字段会被配置成日期类型.而第二条文档如果该字段不是日期字符串则会抛错
----在index的某个type上将date_detection关闭
put /books
{
    "mappings":{
        "it":{
            "date_detection":false
        }
    }
}
----静态映射
put schools
{
    "mappings":{
        "user":{
            "_all":{"enabled":false},
            "properties":{
                "title":{"type":"text"},
                "name":{"type":"text"},
                "age":{"type":"integer"}
            }
        },
        "blogpost":{
            "_all":{"enabled":true},
            "properties":{
                "title":{"type":"text"},
                "body":{"type":"text"},
                "user_id":{"type":"keyword"},
                "create":{
                    "type":"date",
                    "format":"strict_date_optional_time||epoch_millis"
                }
            }
        }
    }
}
----字段类型
        string  es5.x后抛弃此类型,由text和keyword代替
        text    可以被全文搜索,文本会被分词器分成一个个词项然后索引.text不用于排序,很少用于聚合(termsAggregation除外)
        keyword 不会对内容进行分词,只能被精确搜索到
        数字类型 byte,short,integer,long,float,double,half_float,scaled_float
            对于flaot,half_float,scaled_float来说, -0.0和+0.0是不同的.使用term查询-0.0不会匹配+0.0
            scaled_float 会将值保存为整数,因为省空间?
        date    json没有date类型,所以在es中的日期有以下几种类型.
            格式化的字符串 如 2015-01-01 或者 2015/01/01 12:12:12
            代表 milliseconds-since-the-epoch 的长整数
            代表 seconds-since-the-epoch 的长整数.
            es内部会将日期格式化为UTC,并储存为 milliseconds-since-the-epoch 的长整数.日期格式可以定义,没有自定义则为 strict_date_optional_time||epoch_millis
        boolean 值为 true,false,"true","false",数字
        binary  接受base64的编码,默认不存储?(为啥我能查询到),不能被搜索(这个确实)
        array   默认使用第一个元素的类型,一个数组中的类型必须一致.在文档中使用array类型不需要提前配置.默认支持
        object  json文档中保存文档.写入es后,文档会被索引成简单的扁平key-value结构.
        nested  为了避免对象数组之间的关系被消除,进而出现 nested, 这种类型能保证每个对象的独立性
        range   范围类型
        token_count 用于统计字符串分词后的词项个数
----数字类型配置
put number_index
{
    "mappings":{
        "my_type":{
            "properties":{
                "number_of_types":{"type":"integer"},
                "time_of_types":{"type":"float"},
                "price":{
                    "type":"scaled_float",
                    "scaling_factor":100
                }
            }
        }
    }
}
----binary类型
put binary_index
{
    "mappings":{
        "my_type":{
            "properties":{
                "name":{"type":"text"},
                "blob":{"type":"binary"}
            }
        }
    }
}
post binary_index/my_type
{
    "name":"hello",
    "blob":"aGVsbG93b3JsZA=="
}
----array类型,array的查询
post binary_index/my_type
{
    "name":"hello",
    "blob":"aGVsbG93b3JsZA==",
    "messages":["es","java"],
    "lists":[
        {"name":"prog_list"},
        {"name":"cool_list"}
    ]
}
get /binary_index
{
    "query":{
        "match":{
            "lists.name":"list"
        }
    }
}
----object mapping
put object_index
{
    "mappings":{
        "my_type":{
            "properties":{
                "region":{"type":"keyword"},
                "manager":{
                    "properties":{
                        "age":{"type":"integer"},
                        "name":{"type":"text"}
                    }
                }
            }
        }
    }
}
----但是由于object只是将对象数组偏平化,转成简单列表.所以有时候会有问题
put object/index
{
    "groups":"fans",
    "user":[
        {
            "first":"john",
            "last":"smith"
        },{
            "first":"alice",
            "last":"white"
        }
    ]
}
----会被储存成下边的形式,对象数组的对象内容将会失去联系
{
    "groups":"fans",
    "user.first":["john","alice"],
    "user.last":["smith","white"]
}
----以下查询会被搜索到
get /object_index/my_type/_search
{
    "query":{
        "bool":{
            "must":[
                {"match":{"user.first":"alice"}},
                {"match":{"user.last":"smith"}}
            ]
        }
    }
}
----将上述对象修改成 nested .在进行搜索等就搜索不到了
put object_index
{
    "mappings":{
        "my_type":{
            "properties":{
                "user":{
                    "type":"nested"
                }
            }
        }
    }
}
----范围类型
put range_index
{
    "mappings":{
        "my_type":{
            "properties":{
                "expected_attendees":{
                    "type":"integer_range"
                },
                "time_frame":{
                    "type":"date_range",
                    "format":"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"
                }
            }
        }
    }
}
----写入范围
put range_index/my_type/1
{
    "expected_attendees":{
        "gte":10,
        "lte":20
    },
    "time_frame":{
        "gte":"2015-02-02 12:00:00",
        "lte":"2015-09-09"
    }
}
----token_count
put token_index
{
    "mappings":{
        "my_type":{
            "properties":{
                "name":{
                    "type":"text",
                    "fields":{
                        "length":{
                            "type":"token_count",
                            "analyzer":"standard"
                        }
                    }
                }
            }
        }
    }
}
----放入数据 发现并没有储存 name.length字段
put token_index/my_type
{
    "name":"john smith"
}
put token_index/my_type
{
    "name":"richals tom jerry"
}
----搜索 token_count.虽然没有储存token_count字段,但是却可以搜索到
get token_index/my_type
{
    "query":{
        "term":{
            "name.length":3
        }
    }
}